{
  "schema_version": "1.0.0",
  "last_updated": "2025-10-08T11:43:59+05:30",
  "description": "MCP-enhanced tool usage patterns for error prevention and validation",
  
  "mcp_integration": {
    "memory_storage": {
      "location": ".windsurf/memory-bank/aegis-knowledge-graph",
      "purpose": "Unlimited local storage for tool patterns, mistakes, and recovery strategies",
      "status": "Primary and only knowledge store via @mcp:memory (ByteRover fully replaced)"
    },
    "validation_mcps": {
      "pre_call": ["@mcp:sequential-thinking", "@mcp:memory"],
      "execution": ["@mcp:filesystem", "@mcp:git"],
      "post_call": ["@mcp:context7", "@mcp:memory"],
      "fallback": ["@mcp:fetch", "@mcp:time"]
    }
  },

  "tool_patterns": {
    "replace_file_content": {
      "correct_format": {
        "TargetFile": "/absolute/path/to/file.ext",
        "ReplacementChunks": [
          {
            "TargetContent": "exact text to match including whitespace",
            "ReplacementContent": "replacement text",
            "AllowMultiple": false
          }
        ],
        "Instruction": "Brief description of changes"
      },
      "common_mistakes": [
        {
          "mistake": "Stringified JSON array",
          "wrong": "{\"ReplacementChunks\": \"[{\\\"TargetContent\\\"...}]\"}",
          "correct": "{\"ReplacementChunks\": [{\"TargetContent\": ...}]}",
          "prevention": "@mcp:sequential-thinking validates array type before call"
        },
        {
          "mistake": "Partial whitespace match",
          "wrong": "TargetContent missing leading/trailing spaces",
          "correct": "Include ALL whitespace in exact match",
          "prevention": "@mcp:filesystem read_text_file to verify exact content"
        }
      ],
      "mcp_validation": {
        "pre_call": "@mcp:filesystem read file to verify TargetContent exists",
        "post_call": "@mcp:git diff to verify changes applied correctly",
        "on_error": "@mcp:context7 resolve-library-id for tool documentation"
      }
    },

    "mcp3_edit_file": {
      "correct_format": {
        "path": "/absolute/path/to/file.ext",
        "edits": [
          {
            "oldText": "exact text to replace",
            "newText": "replacement text"
          }
        ],
        "dryRun": false
      },
      "validation": {
        "type_check": "edits MUST be array of objects, not string",
        "pre_call": "@mcp:memory retrieve previous edit patterns",
        "execution": "@mcp:filesystem validates path exists",
        "post_call": "@mcp:git status to confirm changes"
      }
    },

    "mcp3_write_file": {
      "correct_format": {
        "path": "/absolute/path/to/file.ext",
        "content": "complete file content as string"
      },
      "warnings": [
        "Only for NEW files - use mcp3_edit_file for existing files",
        "Overwrites existing content without warning",
        "Must create parent directories first with mcp3_create_directory"
      ],
      "mcp_safety": {
        "pre_call": "@mcp:filesystem get_file_info to check if file exists",
        "on_exists": "HALT and switch to mcp3_edit_file instead",
        "post_call": "@mcp:memory store creation pattern for future reference"
      }
    },

    "run_command": {
      "correct_format": {
        "CommandLine": "exact command with args",
        "Cwd": "/absolute/working/directory",
        "Blocking": true,
        "SafeToAutoRun": false
      },
      "validation_flow": [
        "@mcp:sequential-thinking decompose command safety",
        "@mcp:memory check if command pattern previously failed",
        "@mcp:filesystem verify Cwd exists",
        "@mcp:time timestamp for execution tracking"
      ],
      "error_recovery": {
        "on_failure": "@mcp:context7 search official docs for command syntax",
        "retry_logic": "@mcp:math exponential backoff calculation",
        "logging": "@mcp:memory store failure pattern with context"
      }
    },

    "grep_search": {
      "correct_format": {
        "Query": "search term or regex pattern",
        "SearchPath": "/absolute/path/to/search",
        "IsRegex": false,
        "CaseInsensitive": true,
        "Includes": ["*.ext"]
      },
      "mcp_optimization": {
        "pre_search": "@mcp:memory check if similar query cached",
        "execution": "@mcp:filesystem validates SearchPath",
        "post_search": "@mcp:memory cache results for 5 minutes",
        "pattern_learning": "@mcp:context7 improve regex patterns over time"
      }
    }
  },

  "error_prevention_protocol": {
    "step_1_pre_validation": {
      "mcp": "@mcp:sequential-thinking",
      "action": "Break down tool call into validation steps",
      "checks": [
        "Parameter types match schema",
        "Paths are absolute not relative",
        "Arrays are actual arrays not strings",
        "Required fields present"
      ]
    },
    "step_2_memory_check": {
      "mcp": "@mcp:memory",
      "action": "Query previous similar tool calls",
      "retrieve": [
        "Successful patterns to replicate",
        "Failed patterns to avoid",
        "Known edge cases for this tool"
      ]
    },
    "step_3_execution": {
      "mcp": "@mcp:filesystem or tool-specific MCP",
      "action": "Execute tool call with validated parameters",
      "monitoring": "@mcp:time track execution duration"
    },
    "step_4_verification": {
      "mcp": "@mcp:git",
      "action": "Verify changes applied correctly",
      "fallback": "@mcp:filesystem re-read to confirm"
    },
    "step_5_learning": {
      "mcp": "@mcp:memory",
      "action": "Store outcome for future reference",
      "data": {
        "success": "Store pattern as template",
        "failure": "Store with error details and resolution"
      }
    }
  },

  "silent_failure_detection": {
    "problem": "Tool claims success but edit not applied",
    "detection_strategy": {
      "step_1": "@mcp:git diff to verify actual file changes",
      "step_2": "@mcp:filesystem read_text_file to confirm content",
      "step_3": "@mcp:context7 if mismatch, query why edit failed"
    },
    "prevention": [
      "Always verify edits with @mcp:git status after tool call",
      "Use @mcp:filesystem get_file_info to check modification time",
      "Store verification pattern in @mcp:memory for consistency"
    ]
  },

  "recovery_strategies": {
    "malformed_edit_error": {
      "symptoms": "Model produced a malformed edit that Cascade was unable to apply",
      "recovery": [
        "@mcp:context7 search tool documentation for correct format",
        "@mcp:memory retrieve last successful edit pattern",
        "@mcp:sequential-thinking break edit into smaller chunks",
        "Retry with simplified TargetContent (reduce whitespace complexity)"
      ]
    },
    "tool_not_called": {
      "symptoms": "Cascade failing to call tool despite plan",
      "recovery": [
        "@mcp:memory check if tool previously blacklisted",
        "@mcp:sequential-thinking re-evaluate tool selection",
        "@mcp:context7 verify tool availability in current context",
        "Fallback to alternative tool (e.g., write_to_file vs mcp3_edit_file)"
      ]
    },
    "incorrect_edit_silently_applied": {
      "symptoms": "Wrong edit applied without error message",
      "recovery": [
        "@mcp:git revert to last known good state",
        "@mcp:filesystem read correct content from backup",
        "@mcp:memory log incorrect pattern to avoid repetition",
        "@mcp:context7 analyze why wrong match occurred"
      ]
    }
  },

  "constitutional_integration": {
    "article_reference": "Article XV: Tool Usage & Error Prevention",
    "enforcement": {
      "pre_call_validation": "MANDATORY before ANY tool call",
      "post_call_verification": "MANDATORY after ANY file modification",
      "failure_logging": "mistakes.json updated via @mcp:filesystem",
      "pattern_storage": "systemPatterns.json updated via @mcp:memory"
    },
    "compliance_threshold": "100% - Zero tolerance for tool formatting errors"
  }
}
