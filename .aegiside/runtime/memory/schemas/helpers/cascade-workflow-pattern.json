{
  "schema_version": "1.0.0",
  "critical_fix": "Workflows must be Cascade-compatible patterns, not bash scripts",
  "created": "2025-10-18T02:00:17+05:30",
  
  "core_principle": {
    "workflows_are": "Documentation that Cascade reads and executes step-by-step",
    "workflows_are_not": "Standalone bash scripts that run in single terminal session",
    "execution_model": "Cascade extracts commands → calls run_command for each → chains results"
  },
  
  "cascade_compatible_pattern": {
    "format": "Markdown with atomic command examples in code blocks",
    "structure": {
      "header": "Title and description",
      "steps": "Numbered sections with single-purpose commands",
      "commands": "In ```bash code blocks, one logical operation per block",
      "notes": "Instructions for Cascade in regular text"
    },
    
    "example_template": [
      "---",
      "description: Brief workflow description",
      "---",
      "",
      "# /workflow-name — Title",
      "",
      "## 1. Read Current State",
      "",
      "Query the scratchpad to get next task:",
      "```bash",
      "jq -r '.priority_queue[0].title' .windsurf/aegiside/memory-bank/scratchpad.json",
      "```",
      "",
      "## 2. Process Task",
      "",
      "*(Cascade: Use @mcp:memory to search patterns, @mcp:sequential-thinking to plan)*",
      "",
      "## 3. Update Progress",
      "",
      "Record completion with RL reward:",
      "```bash",
      "jq '.transactions = [{\"workflow\": \"name\", \"rl_reward\": 20}] + .transactions | .total_rl_score += 20' .windsurf/aegiside/memory-bank/progress.json | sponge .windsurf/aegiside/memory-bank/progress.json",
      "```",
      "",
      "## 4. Commit",
      "",
      "```bash",
      "git add -A && git commit -m 'task: complete'",
      "```"
    ]
  },
  
  "atomic_command_rules": {
    "rule_1_single_purpose": {
      "description": "Each command does ONE thing",
      "good": "jq -r '.priority_queue[0]' scratchpad.json",
      "bad": "for file in *.json; do jq ... done"
    },
    
    "rule_2_no_bash_variables": {
      "description": "Don't rely on variables between commands",
      "why": "Each run_command is separate shell",
      "good": "Store in JSON, read in next command",
      "bad": "task=$(jq ...) && echo $task"
    },
    
    "rule_3_absolute_paths": {
      "description": "Use full paths or IDE-relative paths",
      "good": ".windsurf/aegiside/memory-bank/scratchpad.json",
      "bad": "$memory_bank/scratchpad.json (variable won't persist)"
    },
    
    "rule_4_self_contained": {
      "description": "Each command must work independently",
      "good": "jq '.field = 1' file.json | sponge file.json",
      "bad": "Depends on previous bash variable"
    },
    
    "rule_5_transparent": {
      "description": "Command clearly shows what it does",
      "pattern": "echo '→ ACTION: description' && command",
      "example": "echo '→ UPDATE: RL score' && jq '.total_rl_score += 20' progress.json | sponge progress.json"
    }
  },
  
  "state_management_pattern": {
    "principle": "JSON files are the ONLY state storage",
    "read_pattern": "jq -r '.path.to.field' file.json",
    "write_pattern": "jq '.path.to.field = value' file.json | sponge file.json",
    "no_variables": "Results stored in JSON, not bash variables",
    
    "example_state_flow": [
      "Step 1: jq -r '.priority_queue[0].title' scratchpad.json → Cascade captures output",
      "Step 2: Cascade uses output in next MCP call",
      "Step 3: jq '.status = \"completed\"' activeContext.json | sponge activeContext.json",
      "Step 4: Next command reads updated activeContext.json"
    ]
  },
  
  "forbidden_patterns": {
    "infinite_loops": {
      "pattern": "while true; do ... done",
      "why": "Cascade would propose as single command, hangs IDE",
      "alternative": "Document steps, Cascade/user repeats manually"
    },
    
    "for_loops": {
      "pattern": "for file in *.json; do ... done",
      "why": "Multi-iteration logic doesn't fit run_command model",
      "alternative": "Use jq array processing or explicit commands per file"
    },
    
    "bash_functions": {
      "pattern": "function name() { ... }",
      "why": "Functions don't persist between run_command calls",
      "alternative": "Repeat command pattern or use jq logic"
    },
    
    "variable_chains": {
      "pattern": "a=$(cmd1) && b=$(cmd2) && use $a $b",
      "why": "Variables lost between commands",
      "alternative": "Store in JSON, read back"
    },
    
    "complex_bash": {
      "pattern": "if [[...]]; then ...; fi with multiple lines",
      "why": "Cascade executes commands atomically",
      "alternative": "Simple conditionals OR let Cascade decide logic"
    }
  },
  
  "correct_workflows_structure": {
    "next_md": {
      "purpose": "Execute single task from queue",
      "steps": [
        "1. Read task: jq -r '.priority_queue[0]' scratchpad.json",
        "2. Execute: (Cascade uses MCP tools)",
        "3. Update: jq atomic writes to all schemas",
        "4. Commit: git add -A && git commit",
        "5. Done: Workflow exits, user/Cascade can call /next again"
      ],
      "no_loop": "Execute once and exit, repeat by calling /next again"
    },
    
    "bootstrap_md": {
      "purpose": "Initialize 8 schemas if missing",
      "steps": [
        "1. Check: List files in memory-bank/",
        "2. Create: jq -n '{schema_version: ...}' > schema.json for each missing",
        "3. Validate: jq '.' each schema to verify",
        "4. Commit: git add && git commit",
        "5. Done: Schema initialized"
      ],
      "no_chain": "Don't call /next, let user decide"
    },
    
    "validate_md": {
      "purpose": "Run validation checks",
      "steps": [
        "1. Detect language: Check for package.json, Cargo.toml, etc.",
        "2. Run checks: Language-specific commands",
        "3. If pass: jq update with +15 RL",
        "4. If fail: jq update with penalty, render article with glow",
        "5. Done: Exit with appropriate code"
      ]
    }
  },
  
  "parallel_operations_pattern": {
    "challenge": "run_command executes sequentially, not parallel",
    "solution": "Use jq array processing or explicit command per item",
    "example_read_parallel": {
      "old_wrong": "task=$(jq ...) & score=$(jq ...) & wait",
      "new_correct": [
        "jq -r '.priority_queue[0]' scratchpad.json",
        "jq -r '.total_rl_score' progress.json",
        "(Cascade calls both, uses results)"
      ]
    },
    "note": "Cascade can call multiple run_command in parallel if needed"
  },
  
  "glow_rendering_pattern": {
    "purpose": "Display constitutional articles beautifully",
    "command": "cat .windsurf/rules/constitution/path/article.md | glow -",
    "when_to_use": "On errors, for guidance, during parliamentary sessions",
    "example": {
      "step": "## Render Error Guidance",
      "command": "cat .windsurf/rules/constitution/08-judiciary/article-36.md | glow -",
      "note": "Cascade executes, user sees beautiful terminal UI"
    }
  },
  
  "mcp_integration_pattern": {
    "when_to_use_mcps": [
      "@mcp:context7: Fetch official documentation on errors",
      "@mcp:exa: Research cutting-edge solutions",
      "@mcp:memory: Query/update knowledge graph",
      "@mcp:sequential-thinking: Plan complex tasks"
    ],
    "pattern_in_workflow": [
      "## 2. Research Solution",
      "",
      "*(Cascade: Use @mcp:context7 to fetch React docs)*",
      "*(Cascade: Use @mcp:sequential-thinking to plan fix)*"
    ],
    "note": "MCP calls are Cascade's internal logic, not bash commands"
  },
  
  "correct_auto_chaining": {
    "wrong_way": "while true; do execute_task; done",
    "right_way": [
      "1. Workflow executes ONCE and exits",
      "2. At end: echo '→ TIP: Run /next to continue'",
      "3. User or Cascade calls /next again",
      "4. Repeat"
    ],
    "cascade_automation": "Cascade can be told to 'keep running /next until queue empty'"
  },
  
  "safety_and_transparency": {
    "echo_before_action": "echo '→ ACTION: description' && command",
    "safe_to_autorun": "Read-only commands (jq -r, cat, ls) = SafeToAutoRun:true",
    "require_approval": "Write commands (jq | sponge, git commit) = SafeToAutoRun:false",
    "error_handling": "Commands that fail return non-zero, Cascade sees failure",
    "user_control": "User can review/modify each command before execution"
  },
  
  "benefits_of_this_model": {
    "transparency": "User sees EVERY command before it runs",
    "control": "User can approve/reject/modify each step",
    "debugging": "Clear which command succeeded/failed",
    "portability": "Works in Windsurf, Cursor, VS Code with similar patterns",
    "safety": "No hidden script execution, no infinite loops",
    "simplicity": "Atomic commands easier to understand than complex scripts"
  },
  
  "cli_pipeline_still_optimal": {
    "why": [
      "jq commands are atomic (perfect for run_command)",
      "No bash variables needed (state in JSON)",
      "Each operation independent",
      "Fast execution (native binaries)",
      "Transparent (user sees exact jq command)"
    ],
    "conclusion": "CLI pipeline + Cascade run_command = optimal combination"
  },
  
  "migration_checklist": [
    "✓ Remove all 'while true' loops",
    "✓ Remove bash variable dependencies",
    "✓ Break complex scripts into atomic commands",
    "✓ Add transparency echoes",
    "✓ Use absolute/relative paths (not bash variables)",
    "✓ One logical operation per code block",
    "✓ Add 'TIP: Run /next' instead of auto-chaining",
    "✓ Test in actual Windsurf IDE"
  ]
}
